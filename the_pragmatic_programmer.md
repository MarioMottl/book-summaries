# The Pragmatic Programmer - Quick Reference Guide

## Bite 1: Core Philosophy & Mindset

* **Take Ownership**
  * Be responsible for your career and code
* **Be Pragmatic**
  * Cultivate adaptability, curiosity, critical thinking, and realism
* **No Excuses**
  * Provide options instead of making excuses
* **Fix Broken Windows**
  * Don't let code deteriorate - fix issues while small
* **Be a Catalyst**
  * Drive positive change while staying alert to negative patterns
* **Good Enough Software**
  * Accept that perfect software doesn't exist
* **Knowledge Investment**
  * Continuously learn and experiment
* **Communication**
  * Master active listening and clear articulation

## Bite 2: Pragmatic Approach

* **Design for Change**
  * Good design is flexible and adaptable
* **DRY Principle**
  * Don't Repeat Yourself - avoid duplication
* **Orthogonality**
  * Keep components independent and decoupled
* **Tracer Bullets**
  * Build thin end-to-end slices for quick feedback
* **Prototyping**
  * Use prototypes to learn and experiment
* **Domain Languages**
  * Program close to the problem domain
* **Estimation**
  * Learn to estimate to prevent surprises

## Bite 3: Basic Tools

* **Plain Text**
  * Prefer plain text for storing knowledge
* **Shell Power**
  * Master command line tools and automation
* **Power Editing**
  * Become fluent in your editor
* **Version Control**
  * Track everything in version control
* **Debugging**
  * Debug with a clear head and systematic approach
* **Text Manipulation**
  * Learn tools for manipulating text
* **Engineering Daybook**
  * Keep notes of what you learn

## Bite 4: Pragmatic Paranoia

* **Design by Contract**
  * Define preconditions, postconditions, and invariants
* **Dead Programs**
  * Crash early rather than continue in unstable state
* **Assertions**
  * Use assertions to prevent impossible things
* **Resource Balance**
  * Finish what you start - deallocate resources
* **Don't Outrun Headlights**
  * Take small steps, don't look too far ahead

## Bite 5: Bend or Break

* **Decoupling**
  * Avoid tight coupling between components
* **Juggling Requirements**
  * Handle real-world complexity
* **Transform Programming**
  * Use transformations to manipulate code
* **Inheritance**
  * Use composition over inheritance
* **Configuration**
  * Keep configuration external to code

## Bite 6: Concurrency

* **Temporal Coupling**
  * Break time-based dependencies
* **Shared State**
  * Avoid shared state - it leads to problems
* **Actors & Processes**
  * Use message passing between independent actors
* **Blackboards**
  * Consider blackboard systems for loose coupling

## Bite 7: While Coding

* **Listen to Lizard Brain**
  * Trust your instincts
* **Programming by Coincidence**
  * Avoid coding by accident
* **Algorithm Speed**
  * Understand algorithmic complexity
* **Refactoring**
  * Continuously improve code structure
* **Test Driven**
  * Write tests before code
* **Property Testing**
  * Use property-based testing
* **Security**
  * Stay safe through good practices
* **Naming**
  * Choose names with care

## Bite 8: Before the Project

* **Requirements**
  * Learn real requirements through feedback
* **Impossible Puzzles**
  * Find the real constraints
* **Working Together**
  * Code review and pair program
* **The Essence of Agility**
  * Be truly agile, not just following practices

## Bite 9: Pragmatic Projects

* **Pragmatic Teams**
  * Build and maintain great teams
* **Automation**
  * Automate everything you can
* **Ruthless Testing**
  * Test early, test often, test automatically
* **It's All Writing**
  * Treat documentation as an equal citizen
* **Pride and Prejudice**
  * Sign your work

## Key Takeaways

* No one knows exactly what they want
* Good design is easier to change
* There are no final decisions
* Maintain small, stable teams
* Great software today is better than perfect software tomorrow